package algorithm;

import java.util.ArrayList;

/**
 * The PathGenerator class implements an application that displays the path to
 * fetch the sequence of books generated by Generic class and AntColony class
 * 
 * @author Xueli Jia, Zhao Zhao
 */
public class PathGenerator {
	private float SHELF_VERTICAL_SPACE;
	private float SHELF_HORIAONTAL_SPACE;
	private bookInformation[] bi;
	private ArrayList<Point> coordinateList = new ArrayList<Point>();

	/**
	 * this is the constructor of PathGenerator class to initialize variables
	 * 
	 * @param bi
	 *            store a instance of bookInformation
	 * @param SHELF_VERTICAL_SPACE
	 *            store the vertical space between shelves
	 * @param SHELF_HORIZONTAL_SPACE
	 *            store the horizontal space between shelves
	 */
	public PathGenerator(bookInformation[] bi, float SHELF_VERTICAL_SPACE,
			float SHELF_HORIAONTAL_SPACE) {
		this.bi = bi;
		this.SHELF_VERTICAL_SPACE = SHELF_VERTICAL_SPACE;
		this.SHELF_HORIAONTAL_SPACE = SHELF_HORIAONTAL_SPACE;
	}

	/**
	 * The add method has ability to add a point to the coordinate list it will
	 * judge the position of the point first, and to highlight the line of path,
	 * there is deviation between the point and the real book position
	 * 
	 * @param p
	 *            stores a instance of point
	 */
	public void add(bookInformation p, boolean book) {
		Point temp;
		if (p.leftOrRight() == -1) {
			temp = new Point(p.getBookInformation().getX() - ((float) 1 / 5)
					* SHELF_HORIAONTAL_SPACE, p.getBookInformation().getY());

		} else {
			temp = new Point(p.getBookInformation().getX() + ((float) 1 / 5)
					* SHELF_HORIAONTAL_SPACE, p.getBookInformation().getY());
		}
		if (book) {
			temp.setAsBook();
			temp.setIndex(p.getBookInformation().getIndex());
		}
		coordinateList.add(temp);
	}

	/**
	 * this method has ability to change a point to bookInformation type
	 * 
	 * @param b
	 *            store an instance of bookInformation
	 * @param t
	 *            store an instance of Point
	 * @return bookInformation with 10 parameters
	 */
	public bookInformation pointToBi(bookInformation b, Point t) {
		return new bookInformation(t.getX(), t.getY(), b.getTopLeftCorner()
				.getX(), b.getTopLeftCorner().getY(), b.getTopRightCorner()
				.getX(), b.getTopRightCorner().getY(), b.getButtonLeftCorner()
				.getX(), b.getButtonLeftCorner().getY(), b
				.getButtonRightCorner().getX(), b.getButtonRightCorner().getY());

	}

	/**
	 * this method is to generate the path in Point array form the positions of
	 * two books can be divided into three types X coordinates equal, Y
	 * coordinates equal, and both X and Y coordinates are not equal for each
	 * type, it generates shortest path to fetch the second book from the first
	 * one
	 * 
	 * @return the point array to fetch books
	 */
	public Point[] generatePath() {
		add(bi[0], true);
		for (int i = 1; i < bi.length; i++) {

			/* in the case of x coordinates of the two neighbor points are equal */
			if (bi[i - 1].getBookInformation().getX() == bi[i]
					.getBookInformation().getX()) {
				add(bi[i], true);
				continue;
			}

			/* in the case of Y coordinates of the two neighbor points are equal */
			if (bi[i - 1].getBookInformation().getY() == bi[i]
					.getBookInformation().getY()) {

				if (Math.abs(bi[i].getBookInformation().getX()
						- bi[i - 1].getBookInformation().getX()) == SHELF_HORIAONTAL_SPACE) {
					add(bi[i], true);
					continue;
				}

				if (bi[i].upOrDown() == -2) {
					add(pointToBi(bi[i - 1], new Point(bi[i - 1]
							.getBookInformation().getX(), bi[i - 1]
							.getTopLeftCorner().getY()
							+ ((float) 1 / 5)
							* SHELF_VERTICAL_SPACE)), false);
					add(pointToBi(bi[i], new Point(bi[i].getBookInformation()
							.getX(), bi[i].getTopRightCorner().getY()
							+ ((float) 1 / 5) * SHELF_VERTICAL_SPACE)), false);
					add(bi[i], true);
					continue;
				}

				add(pointToBi(bi[i - 1], new Point(bi[i - 1]
						.getBookInformation().getX(), bi[i - 1]
						.getButtonLeftCorner().getY()
						- ((float) 1 / 5)
						* SHELF_VERTICAL_SPACE)), false);
				add(pointToBi(bi[i], new Point(bi[i].getBookInformation()
						.getX(), bi[i].getButtonRightCorner().getY()
						- ((float) 1 / 5) * SHELF_VERTICAL_SPACE)), false);
				add(bi[i], true);
				continue;

			}

			/* both X and Y coordinates of the two neighbor points are different */
			if (Math.abs(bi[i].getBookInformation().getX()
					- bi[i - 1].getBookInformation().getX()) == SHELF_HORIAONTAL_SPACE) {
				add(bi[i], true);
				continue;
			}

			if (Math.abs(bi[i].getBookInformation().getY()
					- bi[i - 1].getBookInformation().getY()) == ((float) 1 / 2)
					* (bi[i - 1].getTopLeftCorner().getY() - bi[i - 1]
							.getButtonLeftCorner().getY())) {
				add(pointToBi(bi[i - 1], new Point(bi[i - 1]
						.getBookInformation().getX(), bi[i - 1]
						.getButtonLeftCorner().getY()
						- ((float) 1 / 5)
						* SHELF_VERTICAL_SPACE)), false);
				add(pointToBi(bi[i], new Point(bi[i].getBookInformation()
						.getX(), bi[i].getButtonLeftCorner().getY()
						- ((float) 1 / 5) * SHELF_VERTICAL_SPACE)), false);
				add(bi[i], true);
				continue;
			}

			if (bi[i - 1].getBookInformation().getY()
					- bi[i].getBookInformation().getY() > 0) {
				add(pointToBi(bi[i - 1], new Point(bi[i - 1]
						.getBookInformation().getX(), bi[i].getTopLeftCorner()
						.getY() + ((float) 1 / 5) * SHELF_VERTICAL_SPACE)),
						false);
				add(pointToBi(bi[i], new Point(bi[i].getBookInformation()
						.getX(), bi[i].getTopLeftCorner().getY()
						+ ((float) 1 / 5) * SHELF_VERTICAL_SPACE)), false);
				add(bi[i], true);
				continue;
			}

			add(pointToBi(bi[i - 1], new Point(bi[i - 1].getBookInformation()
					.getX(), bi[i - 1].getTopLeftCorner().getY()
					+ ((float) 1 / 5) * SHELF_VERTICAL_SPACE)), false);
			add(pointToBi(bi[i], new Point(bi[i].getBookInformation().getX(),
					bi[i - 1].getTopLeftCorner().getY() + ((float) 1 / 5)
							* SHELF_VERTICAL_SPACE)), false);
			add(bi[i], true);
			continue;
		}

		/* create a array to store the result which is a sequence of points */
		Point[] result = new Point[coordinateList.size()];
		coordinateList.toArray(result);
		return result;
	}

	public static void main(String args[]) {
		bookInformation[] bi = new bookInformation[8];
		bi[0] = new bookInformation(11, 47, 6, 52, 11, 52, 6, 32, 11, 32);
		bi[1] = new bookInformation(11, 37, 6, 52, 11, 52, 6, 32, 11, 32);
		bi[2] = new bookInformation(17, 37, 17, 52, 22, 52, 17, 32, 22, 32);
		bi[3] = new bookInformation(28, 37, 28, 52, 33, 52, 28, 32, 33, 32);
		bi[4] = new bookInformation(22, 47, 17, 52, 22, 52, 17, 32, 22, 32);
		bi[5] = new bookInformation(33, 73, 28, 78, 33, 78, 28, 58, 33, 58);
		bi[6] = new bookInformation(50, 21, 50, 26, 55, 26, 50, 6, 55, 6);
		bi[7] = new bookInformation(66, 11, 61, 26, 66, 26, 61, 6, 66, 6);
		PathGenerator pg = new PathGenerator(bi, 6, 6);
		Point[] path = pg.generatePath();
		System.out.println("number of points = " + path.length);
		for (int i = 0; i < path.length; i++)
			System.out.println("[" + path[i].getX() + ", " + path[i].getY()
					+ "]" + "\t   boook? [" + path[i].isABook() + "]");
	}
}